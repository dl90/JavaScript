<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: script.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: script.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
*Don Li
*/

const fs = require ("fs");

//------------dependencies----------------//
/**
 * @const fileLocation: the location/file name of file to aquire data from
 */
const fileLocation = (__dirname + "/meals.csv");
/**
 * @const writeFileName: the location/file name of .txt file to write to
 */
const writeFileName = (__dirname + "/menuOutput.txt");
/**
 * @const writeHtmlFileName: the location/file name of html file to write to
 */
const writeHtmlFileName = (__dirname + "/index.html");
/**
 * @const mealWeightObj: the object storing weights used to sort meal categories
 */
const mealWeightObj = {
  breakfast: 1,
  brunch: 2,
  lunch: 3,
  dinner: 4
};
/**
 * @const HtmlTitle: HTML file title to substitue
 */
const HtmlTitle = "Menu";
/**
 * @const BootStrapLink: link to bootstrap for HTML file
 */
const BootStrapLink = ("https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\"");



/**
 * Reads the file, wrapped in a Promise.
 * @param {string} fileLocation Location of file.
 * @returns {promise} Promise containing readFile.
 */
const readFile = (fileLocation) => {
  return new Promise( (resolve, reject) => {
    fs.readFile(fileLocation, "utf-8", (err, data) => {
      if (err ) {
        reject(err.message);
      } else if (data.length &lt; 0) {
        reject(err = new Error ("File is empty."))
      } else {
        resolve(data);
      }
    })
  })
}
readFile(fileLocation)
  .then(data => dataSplit(data))
  .catch(err => console.log(err))


/**
 * Splits parsed string into 2D array with "\n" and ","
 * @param {string} data String to be split in to a 2D array
 * @returns {array} finalArr 2D array delimited by meal and element
 */
const dataSplit = (data) => {
  /**
  * @const dataArr: 1D array generated by splitting with "\n"
  */
  const dataArr = data.split('\n');

  /**
  * @const finalArr: new 2D array holding elements split with "\n" and ","
  */
  const finalArr = [];

  for(ele of dataArr) {
    const arrByLine = ele.split(',');
    
    if(ele.length > 0) {
      finalArr.push(arrByLine);
    }
  }
  categorySplit(finalArr, mealWeightObj);
  return finalArr;
}


/**
 * categorySplit will organize and sort 2D array into categories (based on mealWeightObj key:value)
 * @param {array} arr 2D array to be categorized
 * @returns {array} finalArr 2D array delimited by meal and element
 */
const categorySplit = (arr, mealWeightObj) => {
  /**
  * @const categoryArr: Dynamically generated array of different types of meals (lunch/dinner)
  */
  const categoryArr = [];
  /**
  * @const categorySortedDataArr: data array rearranged according to categoryArr
  */
  const categorySortedDataArr = [];
  /**
  * @const sortedCategoryArr: data sorted categoryArr according to weight specified in mealWeightObj
  */
  const sortedCategoryArr = [];

  for(ele of arr) {
    /**
    * Nested function that adds each unique mealtype to categoryArr
    * @param {string} category The string of ele[0]
    * @returns {array} an array of unique categories
    */
    const categoryCreate = (category) => {
      if( categoryArr.includes(category) === false) {
        categoryArr.push(category);
      }
      return categoryArr;
    }
    categoryCreate(ele[0]);
  }


  //goes through arr and groups them together by category
  //may be redundent thanks to categorySort and bubbleSort
  for(let i = 0; i &lt; categoryArr.length; i++) {
    for(ele of arr) {
      if(ele[0] === categoryArr[i]) {
        categorySortedDataArr.push(ele);
      }
    }
  }

  //adds mealWeight to categoryArr elements
  /**
  * @const sortValues: Temp array used to store categoryArr with adds weight value specified on the mealWeightObj
  */
  const sortValues = [];
  for(let i = 0; i &lt; categoryArr.length; i++) {
    if(Object.keys(mealWeightObj).includes(categoryArr[i])) {
      sortValues.push(mealWeightObj[categoryArr[i]] + categoryArr[i]) 
    }
  }

  //sorts categoryArr with something similar to bubble sort
  for(let i = 0; i &lt; sortValues.length -1; i++) {
    if( sortValues[i] > sortValues[i+1]) {
      let temp = sortValues[i];
      sortValues[i] = sortValues[i+1];
      sortValues[i+1] = temp;
    }
  }

  //removes mealWeight from each elements of sortedValues and pushing it to the final sorted array
  for(ele of sortValues){
    let str = ele.substring(1);
    sortedCategoryArr.push(str);
  }

  bubbleSort(categorySortedDataArr, sortedCategoryArr);
  return (categorySortedDataArr);
}


/**
* Sorts the elements of arr alphabetically based on sortedCategoryArr
* @param {array} arr Raw data 2D array to be sorted
* @param {array} categoryArr Sorted category array used to catogrize 2D array
* @returns {array} sorted 2D array
*/
const bubbleSort = (arr, categoryArr) => {
  for(let i = 0; i &lt; categoryArr.length; i++) {
    for (let j = 0; j &lt; arr.length; j++) {
      for(let k = 0; k &lt; (arr.length - j - 1); k++) {
        if (arr[k][0] === categoryArr[i]) {
          if(arr[k][1] > arr[k+1][1]) {
            let temp = arr[k];
            arr[k] = arr[k+1];
            arr[k+1] = temp;
          }
        }
      }
    }
  }
  priceCalc(arr, categoryArr);
  return (arr);
}


/**
 * Calculates and reassigns the price values for the meal
 * @param {array} arr sorted 2D array to have the pice recalculated
 * @param {array} categoryArr argument to be passed to another function
 * @returns {array} arr with recaculated prices
 * @return {array} categoryArr to be passed to another function
 */
const priceCalc = (arr, categoryArr) => {

  for(ele of arr) {
    ele[3] = ("$"+(parseFloat(ele[ele.length - 1].substring(1)) * 1.8).toFixed(2));
  }
  stringGeneration(arr, categoryArr);
  return (arr);
}


/**
 * Generates both the txt and html string to be written
 * @param {array} arr sorted 2D array used for string generation
 * @param {array} categoryArr sorted category titles used to group and apped meals in that category
 * @returns {function} calls writeFile and writeHTML
 */
const stringGeneration = (arr, categoryArr) => {
  /**
   * @let finalTxtStringToAppend: the final string generated for txt file
   */
  let finalTxtStringToAppend = "";
  /**
   * @let finalHtmlStringToAppend: the final string generated for html file
   */
  let finalHtmlStringToAppend = ""

  for(let i = 0; i &lt; categoryArr.length; i++) {
    finalTxtStringToAppend += " * " + categoryArr[i].toLowerCase().charAt(0).toUpperCase() + categoryArr[i].substring(1) + " Items *\n";
    finalHtmlStringToAppend += " * " + categoryArr[i].toLowerCase().charAt(0).toUpperCase() + categoryArr[i].substring(1) + " Items *\n";
    for(ele of arr) {
      if (ele[0] === categoryArr[i] &amp;&amp; categoryArr[i] !== undefined ) {
        finalTxtStringToAppend += ele[3] + "\t" + ele[1] + ", " + ele[2] + "\n";
        finalHtmlStringToAppend += ele[3] + " &amp;emsp; " + ele[1] + ", " + ele[2] + "\n";
      }
    }
    finalTxtStringToAppend += "\n";
    finalHtmlStringToAppend += "\n";
  }

return (
writeFile(writeFileName, finalTxtStringToAppend)
  .then(console.log( writeFileName + " - sucessfully written."))
  .catch(err => console.log(err)),
writeHtmlFile(writeHtmlFileName, finalHtmlStringToAppend)
  .then(console.log( writeHtmlFileName + " - sucessfully written."))
  .catch(err => console.log(err)));
}


/**
 * Creates a basic HTML file with boiler code and formated string
 * @param {string} writeHtmlFileName the fileName (directory) to write to
 * @param {string} str the string content to write the file
 * @return {promise} calls writeFile function
 */
const writeHtmlFile = (writeHtmlFileName, str) => {
  return new Promise( (resolve) => {
    /**
     * @let menuStringToAppend: menuString used to store store string to append
     */
    let menuStringToAppend = "";
    /**
     * @const finalStringArr: generated from final string to loop through to append things to
     */
    const finalStringArr = str.split("\n")
    for(ele of finalStringArr) {
      menuStringToAppend += ( "    " + ele + "&lt;br>\n" );
    }

    /**
     * @let htmlBoiler: htmlBoiler string appended with menuString
     */
    let htmlBoiler = 
     ( "\&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n&lt;meta charset=\"UTF-8\">\n"
    + "  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n"
    + "  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n"
    + `  &lt;title>${HtmlTitle}&lt;/title>\n`
    + `  &lt;link rel=\"stylesheet\" href=\"${BootStrapLink}>\n`
    + "&lt;/head>\n\n&lt;body id=\"body\">\n  &lt;p id=\"menu\">\n" );
    
    htmlBoiler += ( menuStringToAppend
    + "  &lt;/p>\n&lt;/body>\n&lt;/html>\n" );

    resolve( writeFile(writeHtmlFileName, htmlBoiler));
  })
}


/**
 * Write formatted string to file
 * @param {string} writeFileName the name/directory of the file to write
 * @param {string} str the string content to write in the file
 * @returns {promise} rejects any errors generated from writeFile
 */
const writeFile = (writeFileName ,str) => {
  return new Promise ( ( reject ) => {
    fs.writeFile(writeFileName, str, "utf-8", (err) => {
      if (err) {
        reject (err.message);
      }
    })
  })
}

module.exports = { readFile, dataSplit, categorySplit, bubbleSort, priceCalc, stringGeneration, writeHtmlFile, writeFile }
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#BootStrapLink:">BootStrapLink:</a></li><li><a href="global.html#bubbleSort">bubbleSort</a></li><li><a href="global.html#categoryArr:">categoryArr:</a></li><li><a href="global.html#categorySortedDataArr:">categorySortedDataArr:</a></li><li><a href="global.html#categorySplit">categorySplit</a></li><li><a href="global.html#dataArr:">dataArr:</a></li><li><a href="global.html#dataSplit">dataSplit</a></li><li><a href="global.html#fileLocation:">fileLocation:</a></li><li><a href="global.html#finalArr:">finalArr:</a></li><li><a href="global.html#finalStringArr:">finalStringArr:</a></li><li><a href="global.html#HtmlTitle:">HtmlTitle:</a></li><li><a href="global.html#mealWeightObj:">mealWeightObj:</a></li><li><a href="global.html#priceCalc">priceCalc</a></li><li><a href="global.html#readFile">readFile</a></li><li><a href="global.html#sortedCategoryArr:">sortedCategoryArr:</a></li><li><a href="global.html#sortValues:">sortValues:</a></li><li><a href="global.html#stringGeneration">stringGeneration</a></li><li><a href="global.html#writeFile">writeFile</a></li><li><a href="global.html#writeFileName:">writeFileName:</a></li><li><a href="global.html#writeHtmlFile">writeHtmlFile</a></li><li><a href="global.html#writeHtmlFileName:">writeHtmlFileName:</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Fri Nov 15 2019 12:34:26 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
