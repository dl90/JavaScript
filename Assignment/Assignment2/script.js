/*
*Don Li
*/

const performance = require("perf_hooks");
const start = performance.performance.now();
const fs = require ("fs");

//------------dependencies----------------//
/**
 * @const fileLocation: the location/file name of file to aquire data from
 */
const fileLocation = (__dirname + "/meals.csv");
/**
 * @const writeFileName: the location/file name of .txt file to write to
 */
const writeFileName = (__dirname + "/menuOutput.txt");
/**
 * @const writeHtmlFileName: the location/file name of html file to write to
 */
const writeHtmlFileName = (__dirname + "/index.html");
/**
 * @const mealWeightObj: the object storing weights used to sort meal categories
 */
const mealWeightObj = {
  breakfast: 1,
  brunch: 2,
  lunch: 3,
  dinner: 4
};
/**
 * @const HtmlTitle: HTML file title to substitue
 */
const HtmlTitle = "Menu";
/**
 * @const BootStrapLink: link to bootstrap for HTML file
 */
const BootStrapLink = ("https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\"");



/**
 * Reads the file, wrapped in a Promise.
 * @param {string} fileLocation Location of file.
 * @returns {promise} Promise containing readFile.
 */
const readFile = (fileLocation) => {
  return new Promise( (resolve, reject) => {
    fs.readFile(fileLocation, "utf-8", (err, data) => {
      if (err ) {
        reject(err.message);
      } else if (data.length < 0) {
        reject(err = new Error ("File is empty."))
      } else {
        resolve(data);
      }
    })
  })
}
readFile(fileLocation)
  .then(data => dataSplit(data))
  .catch(err => console.log(err))


/**
 * Splits parsed string into 2D array with "\n" and ","
 * @param {string} data String to be split in to a 2D array
 * @returns {array} finalArr 2D array delimited by meal and element
 */
const dataSplit = (data) => {
  /**
  * @const dataArr: 1D array generated by splitting with "\n"
  */
  const dataArr = data.split('\n');

  /**
  * @const finalArr: new 2D array holding elements split with "\n" and ","
  */
  const finalArr = [];

  for(ele of dataArr) {
    const arrByLine = ele.split(',');
    
    if(ele.length > 0) {
      finalArr.push(arrByLine);
    }
  }
  categorySplit(finalArr, mealWeightObj);
  return finalArr;
}


/**
 * categorySplit will organize and sort 2D array into categories (based on mealWeightObj key:value)
 * @param {array} arr 2D array to be categorized
 * @returns {array} finalArr 2D array delimited by meal and element
 */
const categorySplit = (arr, mealWeightObj) => {
  /**
  * @const categoryArr: Dynamically generated array of different types of meals (lunch/dinner)
  */
  const categoryArr = [];
  /**
  * @const categorySortedDataArr: data array rearranged according to categoryArr
  */
  const categorySortedDataArr = [];
  /**
  * @const sortedCategoryArr: data sorted categoryArr according to weight specified in mealWeightObj
  */
  const sortedCategoryArr = [];

  for(ele of arr) {
    /**
    * Nested function that adds each unique mealtype to categoryArr
    * @param {string} category The string of ele[0]
    * @returns {array} an array of unique categories
    */
    const categoryCreate = (category) => {
      if( categoryArr.includes(category) === false) {
        categoryArr.push(category);
      }
      return categoryArr;
    }
    categoryCreate(ele[0]);
  }


  //goes through arr and groups them together by category
  //may be redundent thanks to categorySort and bubbleSort
  for(let i = 0; i < categoryArr.length; i++) {
    for(ele of arr) {
      if(ele[0] === categoryArr[i]) {
        categorySortedDataArr.push(ele);
      }
    }
  }

  //adds mealWeight to categoryArr elements
  /**
  * @const sortValues: Temp array used to store categoryArr with adds weight value specified on the mealWeightObj
  */
  const sortValues = [];
  for(let i = 0; i < categoryArr.length; i++) {
    if(Object.keys(mealWeightObj).includes(categoryArr[i])) {
      sortValues.push(mealWeightObj[categoryArr[i]] + categoryArr[i]) 
    }
  }

  //sorts categoryArr with something similar to bubble sort
  for(let i = 0; i < sortValues.length -1; i++) {
    if( sortValues[i] > sortValues[i+1]) {
      let temp = sortValues[i];
      sortValues[i] = sortValues[i+1];
      sortValues[i+1] = temp;
    }
  }

  //removes mealWeight from each elements of sortedValues and pushing it to the final sorted array
  for(ele of sortValues){
    let str = ele.substring(1);
    sortedCategoryArr.push(str);
  }

  bubbleSort(categorySortedDataArr, sortedCategoryArr);
  return (categorySortedDataArr);
}


/**
* Sorts the elements of arr alphabetically based on sortedCategoryArr
* @param {array} arr Raw data 2D array to be sorted
* @param {array} categoryArr Sorted category array used to catogrize 2D array
* @returns {array} sorted 2D array
*/
const bubbleSort = (arr, categoryArr) => {
  for(let i = 0; i < categoryArr.length; i++) {
    for (let j = 0; j < arr.length; j++) {
      for(let k = 0; k < (arr.length - j - 1); k++) {
        if (arr[k][0] === categoryArr[i]) {
          if(arr[k][1] > arr[k+1][1]) {
            let temp = arr[k];
            arr[k] = arr[k+1];
            arr[k+1] = temp;
          }
        }
      }
    }
  }
  priceCalc(arr, categoryArr);
  return (arr);
}


/**
 * Calculates and reassigns the price values for the meal
 * @param {array} arr sorted 2D array to have the pice recalculated
 * @param {array} categoryArr argument to be passed to another function
 * @returns {array} arr with recaculated prices
 * @return {array} categoryArr to be passed to another function
 */
const priceCalc = (arr, categoryArr) => {

  for(ele of arr) {
    ele[3] = ("$"+(parseFloat(ele[ele.length - 1].substring(1)) * 1.8).toFixed(2));
  }
  stringGeneration(arr, categoryArr);
  return (arr);
}


/**
 * Generates both the txt and html string to be written
 * @param {array} arr sorted 2D array used for string generation
 * @param {array} categoryArr sorted category titles used to group and apped meals in that category
 * @returns {function} calls writeFile and writeHTML
 */
const stringGeneration = (arr, categoryArr) => {
  /**
   * @let finalTxtStringToAppend: the final string generated for txt file
   */
  let finalTxtStringToAppend = "";
  /**
   * @let finalHtmlStringToAppend: the final string generated for html file
   */
  let finalHtmlStringToAppend = ""

  for(let i = 0; i < categoryArr.length; i++) {
    finalTxtStringToAppend += " * " + categoryArr[i].toLowerCase().charAt(0).toUpperCase() + categoryArr[i].substring(1) + " Items *\n";
    finalHtmlStringToAppend += " * " + categoryArr[i].toLowerCase().charAt(0).toUpperCase() + categoryArr[i].substring(1) + " Items *\n";
    for(ele of arr) {
      if (ele[0] === categoryArr[i] && categoryArr[i] !== undefined ) {
        finalTxtStringToAppend += ele[3] + "\t" + ele[1] + ", " + ele[2] + "\n";
        finalHtmlStringToAppend += ele[3] + " &emsp; " + ele[1] + ", " + ele[2] + "\n";
      }
    }
    finalTxtStringToAppend += "\n";
    finalHtmlStringToAppend += "\n";
  }

return (
writeFile(writeFileName, finalTxtStringToAppend)
  .then(console.log( writeFileName + " - sucessfully written."))
  .catch(err => console.log(err)),
writeHtmlFile(writeHtmlFileName, finalHtmlStringToAppend)
  .then(console.log( writeHtmlFileName + " - sucessfully written."))
  .catch(err => console.log(err)));
}


/**
 * Creates a basic HTML file with boiler code and formated string
 * @param {string} writeHtmlFileName the fileName (directory) to write to
 * @param {string} str the string content to write the file
 * @return {promise} calls writeFile function
 */
const writeHtmlFile = (writeHtmlFileName, str) => {
  return new Promise( (resolve) => {
    /**
     * @let menuStringToAppend: menuString used to store store string to append
     */
    let menuStringToAppend = "";
    /**
     * @const finalStringArr: generated from final string to loop through to append things to
     */
    const finalStringArr = str.split("\n")
    for(ele of finalStringArr) {
      menuStringToAppend += ( "    " + ele + "<br>\n" );
    }

    /**
     * @let htmlBoiler: htmlBoiler string appended with menuString
     */
    let htmlBoiler = 
     ( "\<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n"
    + "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n"
    + "  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n"
    + `  <title>${HtmlTitle}</title>\n`
    + `  <link rel=\"stylesheet\" href=\"${BootStrapLink}>\n`
    + "</head>\n\n<body id=\"body\">\n  <p id=\"menu\">\n" );
    
    htmlBoiler += ( menuStringToAppend
    + "  </p>\n</body>\n</html>\n" );

    resolve( writeFile(writeHtmlFileName, htmlBoiler));
  })
}


/**
 * Write formatted string to file
 * @param {string} writeFileName the name/directory of the file to write
 * @param {string} str the string content to write in the file
 * @returns {promise} rejects any errors generated from writeFile
 */
const writeFile = (writeFileName ,str) => {
  return new Promise ( ( reject ) => {
    fs.writeFile(writeFileName, str, "utf-8", (err) => {
      if (err) {
        reject (err.message);
      }
    })
  })
}

module.exports = { readFile, dataSplit, categorySplit, bubbleSort, priceCalc, stringGeneration, writeHtmlFile, writeFile }

/**
 * @let used to calculate program runtime
 */
let end = performance.performance.now();
console.info( ("Runtime: " + (end - start) + " ms") );
